# ── builder stage ────────────────────────────────────────────────────────────
# Each major step is its own RUN layer so Docker/Podman can cache them
# independently. Cache mounts keep apt, cargo and Go module downloads across
# rebuilds without bloating the final layers.
FROM docker.io/library/debian:bookworm AS builder

ARG DEBIAN_FRONTEND=noninteractive
ENV LANG=C.UTF-8
# Keep rust toolchain inside the image layer so subsequent RUN steps find it.
# Only the downloaded registry/crates are kept in a cache mount.
ENV CARGO_HOME=/usr/local/cargo
ENV RUSTUP_HOME=/usr/local/rustup
ENV PATH="/usr/local/cargo/bin:/usr/local/rustup/bin:/usr/local/go/bin:${PATH}"
ARG OSTREE_VERSION=v2025.3
ARG GO_VERSION=1.24.6

# ── system dependencies ───────────────────────────────────────────────────────
# Cache mount keeps the downloaded .deb files across rebuilds; the layer is
# only invalidated when the package list below changes.
RUN \
    --mount=type=cache,dst=/var/cache/apt,sharing=locked \
    --mount=type=cache,dst=/var/lib/apt,sharing=locked \
    apt update -y && \
    apt install -y \
        git \
        curl \
        make \
        build-essential \
        autoconf \
        automake \
        libtool \
        gettext \
        gperf \
        bison \
        flex \
        go-md2man \
        libarchive-dev \
        libglib2.0-dev \
        libassuan-dev \
        libdevmapper-dev \
        libgpgme-dev \
        liblzma-dev \
        libcap-dev \
        libfuse3-dev \
        libcurl4-gnutls-dev \
        libzstd-dev \
        pkgconf \
        dracut \
        pkg-config \
        libext2fs-dev \
        libssl-dev

# ── ostree ────────────────────────────────────────────────────────────────────
# Layer is invalidated only when OSTREE_VERSION changes.
RUN \
    git clone --depth 1 --branch "${OSTREE_VERSION}" \
        "https://github.com/ostreedev/ostree.git" /build/ostree && \
    cd /build/ostree && \
    ./autogen.sh --prefix=/usr --sysconfdir=/etc --disable-gtk-doc --disable-man && \
    make -j"$(nproc)" && \
    make install && \
    make install DESTDIR=/build/ostree-dist && \
    pkg-config --exists 'ostree-1 >= 2025.3' && \
    ldconfig

# ── rust toolchain ────────────────────────────────────────────────────────────
# Toolchain binaries land in CARGO_HOME/RUSTUP_HOME (both in /usr/local, inside
# the layer) so later RUN steps can use them without re-installing.
RUN \
    curl \
        --proto '=https' \
        --tlsv1.2 \
        -sSf "https://sh.rustup.rs" | sh -s -- --profile minimal -y && \
    rustup --version && cargo --version

# ── bootupctl stub ────────────────────────────────────────────────────────────
# A tiny static binary that exits 0 so bootc's supports_bootupd() check
# passes; at PhobOS level we use u-boot, not bootupd.
RUN \
    mkdir -p /build/bootupd/updates && \
    printf 'int main(void){return 0;}\n' > /tmp/bootupctl.c && \
    gcc -static -Os -s /tmp/bootupctl.c -o /build/bootupd/bootupctl

# ── Go toolchain ──────────────────────────────────────────────────────────────
# Installed to /usr/local/go; stays in the image layer so the skopeo step below
# can use it without downloading again.
RUN \
    GO_ARCH="$(dpkg --print-architecture)" && \
    case "${GO_ARCH}" in \
        amd64) GO_TARBALL_ARCH='amd64' ;; \
        arm64) GO_TARBALL_ARCH='arm64' ;; \
        *) echo "unsupported architecture for Go: ${GO_ARCH}" >&2; exit 1 ;; \
    esac && \
    curl -fsSL "https://go.dev/dl/go${GO_VERSION}.linux-${GO_TARBALL_ARCH}.tar.gz" -o /tmp/go.tgz && \
    tar -C /usr/local -xzf /tmp/go.tgz && \
    go version

# ── skopeo ────────────────────────────────────────────────────────────────────
# Go module cache is preserved across rebuilds; layer invalidated only if the
# skopeo repo HEAD changes.
RUN \
    --mount=type=cache,dst=/root/go/pkg/mod,sharing=locked \
    git clone --depth 1 "https://github.com/containers/skopeo.git" /build/skopeo && \
    make -C /build/skopeo bin/skopeo GOFLAGS=-mod=mod

# ── bootc ─────────────────────────────────────────────────────────────────────
# Cargo registry cache drastically cuts down compile time on rebuilds.
# The actual built binaries land in /build/bootc-dist which is a real layer.
RUN \
    --mount=type=cache,dst=/usr/local/cargo/registry,sharing=locked \
    --mount=type=cache,dst=/usr/local/cargo/git,sharing=locked \
    --mount=type=cache,dst=/build/bootc-target-cache,sharing=locked \
    git clone "https://github.com/gaiaBuildSystem/bootc.git" /build/bootc && \
    ln -s /build/bootc-target-cache /build/bootc/target && \
    make -C /build/bootc bin && \
    make -C /build/bootc install-all DESTDIR=/build/bootc-dist

# ── final stage ──────────────────────────────────────────────────────────────
FROM docker.io/library/debian:bookworm

ARG DEBIAN_FRONTEND=noninteractive
ENV LANG=C.UTF-8

# basic deps
RUN \
    apt update -y && \
    apt install -y \
        bubblewrap \
        btrfs-progs \
        dosfstools \
        e2fsprogs \
        fdisk \
        podman \
        libarchive13 \
        systemd \
        systemd-timesyncd \
        systemd-boot* \
        kmod \
        locales \
        sudo \
        bash \
        bash-completion \
        util-linux \
        htop \
        e2fsprogs \
        parted \
        dbus \
        udev \
        network-manager \
        polkitd \
        net-tools \
        runc \
        xfsprogs && \
    apt clean -y

# enable what is needed for systemd to work properly in the container
RUN \
    mkdir -p /sbin && \
    ln -sf /usr/lib/systemd/systemd /sbin/init && \
    stat /sbin/init && \
    systemctl enable systemd-timesyncd

# copy the kernel
COPY modules /usr/lib/modules

# set the root passwordless
RUN echo "root ALL=(ALL) NOPASSWD:ALL" >> /etc/sudoers && \
    passwd -d root

# install compiled artifacts from the builder stage.
# Each project is bind-mounted temporarily (never stored as a layer) and its
# own install command runs directly against the live image filesystem.

# ostree
RUN \
    --mount=type=bind,from=builder,src=/build/ostree-dist,dst=/mnt/ostree-dist \
    cp -a /mnt/ostree-dist/. / && \
    ldconfig

# bootupctl stub + bootupd directory
RUN \
    --mount=type=bind,from=builder,src=/build/bootupd,dst=/mnt/bootupd \
    install -m 0755 /mnt/bootupd/bootupctl /usr/bin/bootupctl && \
    mkdir -p /usr/lib/bootupd/updates

# skopeo
RUN \
    --mount=type=bind,from=builder,src=/build/skopeo,dst=/mnt/skopeo \
    install -m 0755 /mnt/skopeo/bin/skopeo /usr/bin/skopeo && \
    /usr/bin/skopeo --version

# bootc
RUN \
    --mount=type=bind,from=builder,src=/build/bootc-dist,dst=/mnt/bootc-dist \
    cp -a /mnt/bootc-dist/. /

RUN apt update -y && \
    apt install -y \
        neofetch \
        xterm \
    && \
    apt clean -y

# PhobOS customization
COPY files/systemd/bootc-booted.service /etc/systemd/system/bootc-booted.service
COPY files/systemd/bootc-u-boot.service /etc/systemd/system/bootc-u-boot.service
COPY files/systemd/ostree-finalize-staged.service /etc/systemd/system/ostree-finalize-staged.service
COPY files/systemd/ostree-finalize-staged-hold.service /etc/systemd/system/ostree-finalize-staged-hold.service

RUN systemctl enable \
    bootc-booted.service \
    bootc-u-boot.service \
    ostree-finalize-staged.service \
    ostree-finalize-staged-hold.service

# Necessary for general behavior expected by image-based systems
RUN \
    sed -i 's|^HOME=.*|HOME=/var/home|' "/etc/default/useradd" && \
    rm -rf /boot /home /root /usr/local /usr/etc /srv /var && \
    mkdir -p /sysroot /boot /usr/lib/ostree /var && \
    ln -s sysroot/ostree /ostree && \
    ln -s var/roothome /root && \
    ln -s var/srv /srv && \
    ln -s var/opt /opt && \
    ln -s var/mnt /mnt && \
    ln -s var/home /home && \
    echo "$(for dir in opt home srv mnt usrlocal ; do echo "d /var/$dir 0755 root root -" ; done)" | tee -a "/usr/lib/tmpfiles.d/bootc-base-dirs.conf" && \
    printf "d /var/roothome 0700 root root -\nd /run/media 0755 root root -" | tee -a "/usr/lib/tmpfiles.d/bootc-base-dirs.conf" && \
    printf '[sysroot]\nreadonly = true\n' | tee "/usr/lib/ostree/prepare-root.conf"

# this is bootc recommendation
# to label the image as a bootable container
LABEL containers.bootc=1

# lint the image
RUN bootc container lint
